#include <iostream>
#include <algorithm>
using namespace std;

int dp[1001][10];

int main()
{
    cin.tie(NULL);
	ios_base::sync_with_stdio(false);
    int n, temp;
    long long ans = 0;
    /*
    n = 1: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 == 10
    n = 2: 00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 11, 12, 13, 14, 15, 16 ... == 55
    n = 3: 000, 001, 002, 003, 004, 005, 006, 007, 008, 009, 011, 012, 013, 014 ... == 220

    수의 길이가 늘어날때마다 끝나는 자리 숫자에 따라 가능한 숫자 수가 다르다.
    예를들어 끝자리가 0이라면 0~9까지 10개의 새로운 숫자가 만들어질 수 있지만,
    끝자리가 9일 경우 9가 붙은 숫자 하나밖에 새로 만들어지지 않는다.

    n = 2일때는 0에 10, 1에 9, 2에 8 ... 9에 1 같은 식으로 되기 때문에 1 부터 10까지 더해서 55가 된다.
    n = 3일때는 00에 10, 01에 9 ... 09에 1, 그리고 11에 9, 12에 8 ... 19에 1 같은 식으로 이전 배열을 더해서 된다.
    */

    cin >> n;

    // n = 1
    for (int i = 0; i < 10; i++) {
        dp[1][i] = 1;
    }

    // n = 2
    for (int i = 0; i < 10; i++) {
        dp[2][i] = 10 - i;
    }

    // n >= 3
    for (int i = 3; i <= n; i++) {
        for (int j = 9; j >= 0; j--) {
            if (j == 9) {
                dp[i][j] = 1;
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j+1];
            }

            dp[i][j] %= 10007;
        }
    }

    for (int i = 0; i < 10; i++) {
        ans += dp[n][i];
    }

    ans %= 10007;

    cout << ans;

    return 0;
}
